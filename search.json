[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Приветствую на сайте!",
    "section": "",
    "text": "Дополнительно\nПодробнее обо мне здесь.\nНе стесняйтесь связаться со мной с помощью кнопок ниже!\n\n \n  \n   \n  \n    \n     Telegram\n  \n  \n    \n     WhatsApp\n  \n  \n    \n     Email"
  },
  {
    "objectID": "index.html#блог",
    "href": "index.html#блог",
    "title": "Приветствую на сайте!",
    "section": "Блог",
    "text": "Блог\nПерейдите по ссылке для просмотра публикаций в блоге\n\n\n\n\n\n\n\n\n\n\nПерсональная база знаний\n\n\n\n\n\nOrg Roam\n\n\n\n\n\n2 авг. 2024 г.\n\n\n\n\n\n\n\n\n\n\n\n\nEmacs против других IDE\n\n\n\n\n\nзнакомы с Emacs?\n\n\n\n\n\n11 июл. 2024 г.\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "index.html#портфолио",
    "href": "index.html#портфолио",
    "title": "Приветствую на сайте!",
    "section": "Портфолио",
    "text": "Портфолио\nПерейдите по ссылке для просмотра публикаций в портфолио\n\n\n\n\n\n\n\n\nВеб-скрейпинг\n\n\nrequests bs4\n\n\n\n\n\n\n20 июл. 2024 г.\n\n\n\n\n\n\n\n\n\n\n\n\nКрасивый экспорт в Excel (xlsx)\n\n\nopenxlsx\n\n\n\n\n\n\n10 июл. 2024 г.\n\n\n\n\n\n\n\n\n\n\n\n\nПродажа твердого сыра\n\n\nplotrix\n\n\n\n\n\n\n6 июл. 2024 г.\n\n\n\n\n\n\n\n\n\n\n\n\nРазрез выручки\n\n\nwebr, plotly\n\n\n\n\n\n\n3 июл. 2024 г.\n\n\n\n\n\n\n\n\n\n\n\n\nПродажи предприятий\n\n\nggplot2, scales\n\n\n\n\n\n\n1 июл. 2024 г.\n\n\n\n\n\n\n\n\nНет подходящих элементов"
  },
  {
    "objectID": "content/portfolio/posts/p5.html",
    "href": "content/portfolio/posts/p5.html",
    "title": "Веб-скрейпинг",
    "section": "",
    "text": "Этот код позволяет парсить информацию о вакансиях на hh.ru Он сканирует начальную страницу, находит вакансии, переходит по ссылкам на вакансии и собирает указанные данные\n\nИмпорт и настройки\nОсновными библиотеками для парсинга выступают: 1. requests - делает запрос на сайт и получает данные 2. bs4 (BeautifulSoup) - парсит результат запроса requests\n\n\nКод\nimport requests\nfrom bs4 import BeautifulSoup\nimport polars as pl\nimport re\nimport xlsxwriter\nimport time\n\ndf = pl.DataFrame({             # 1\n    \"Вакансия\": pl.Series([], dtype=pl.Utf8),\n    \"Зарплата\": pl.Series([], dtype=pl.Int64),\n    \"Keyword\": pl.Series([], dtype=pl.Utf8),\n    \"Tags\": pl.Series([], dtype=pl.Utf8),\n    \"URL\": pl.Series([], dtype=pl.Utf8)\n})\n\n#^2\nstart_url = \"https://hh.ru/search/vacancy?experience=between1And3&order_by=publication_time&ored_clusters=true&schedule=remote&text=sql&search_period=7\"\n\nurl = start_url                 # 3\n\nheaders = {                     # 4\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n    \"Accept-Language\": \"en-US,en;q=0.9\",\n    \"Accept-Encoding\": \"gzip, deflate, br\",\n    \"Connection\": \"keep-alive\",\n    \"Upgrade-Insecure-Requests\": \"1\"\n}\n\nkeywords = [\"BPMN\", \"Jira\"]     # 5\n\n\n\nСоздаем пустую таблицу, в эту таблицу будет добавляться найденная информация о вакансиях\nСтартовая страница запроса, эта строка учитывает указанные фильтры на hh, то есть, можно перейти на hh, указать критерии поиска, выбрать фильтры, а после скопировать ссылку и вставить в скрипт\nЭта ссылка служит основной для перехода, что бы перейти на вторую страницу нужно к ссылке добавить page=номер страницы, я использую код url=f’{start_url}&page={p}’ который имеет константу страницы start_url, и конкатинацию в зависимости от итерации цикла\nЭти настройки нужны при запросе requests.get(), для имитации, что запрос на страницу делает пользователь, когда сайт запрашивает данные, мы ему предоставляем данные из этого списка\nКлючевые слова, которые скрипт будет искать на страницах вакансий\n\n\n\nПроверка полученной страницы (вакансия)\nПри запросе страницы бывает приходит страница не полная, у которой нет части данных. Эта функция проверяет наличие данных, если они не полные то делает запрос повторно\n\n\nКод\ndef check_correctly(url):\n     for i in range(9):         # ^1\n          response = requests.get(url, headers=headers) # 2\n          soup = BeautifulSoup(response.text, 'html.parser') # 3\n\n          header = soup.find('div', {'class': 'vacancy-title'}) # 4\n          if header:                                            # 5\n               visit_and_check(url, soup, response)             # 6\n               break\n\n\n\nЕсли данные приходят не полные, то повторяем запрос\nСам запрос на получение данных с сайта, url - ссылка данные которой запрашиваем, headers - это имитация пользователя которая создавалась ранее\nПарсим полученный объект (теперь в этой переменной лежит “грубо говоря” html страница), которую можно парсить. Преимущество в том, что при тестах не делается запрос на сайт\nИщем div class с названием vacancy-title\nПроверяем переменную header,(для чего ? читай описание заголовка), если мы получили полную страницу\nвызываем функцию и передаем url - ссылку, soup - локальную html, response - для поиска слов по всей странице\n\n\n\nСканирование вакансии\nЭта функция извлекает нужные данные страницы\n\n\nКод\ndef visit_and_check(url, soup, response):\n  global df                     # 1\n\n  fkeys = []                    # 2\n\n  for keyword in keywords:      # 3\n      if keyword in response.text: # 4\n        fkeys.append(keyword)      # 5\n\n  # Находим теги (навыки) в нижней части страницы\n  skill_elements = soup.find_all('li', {'data-qa': 'skills-element'}) # 6\n  skills = [li.find('div', class_=re.compile(r'magritte-tag__label')).text for li in skill_elements] # 6.1\n\n  header = soup.find('div', {'class': 'vacancy-title'}) # 7\n  title = header.find('h1').text                        # 8\n\n  salary_str = header.find('span', {'data-qa': 'vacancy-salary-compensation-type-net'}) # 9\n  if salary_str:                # 9.1\n    # Найти первое число в строке с помощью регулярного выражения\n      match = re.search(r'\\d+', salary_str.text.replace('\\xa0', '')) # 9.2\n      if match:\n        salary = int(match.group()) # 9.3\n      else:\n        salary = None           # 9.4\n  else:\n    salary = None               # 9.4\n\n  df = df.vstack(pl.DataFrame({ # 10\n    \"Вакансия\" : [title],\n    \"Зарплата\" : [salary],\n    \"Keyword\": [', '.join(fkeys)],\n    \"Tags\": [', '.join(skills)],\n    \"URL\": [url]}))\n\n\n\nЭта строка нужна для из за пространства имен, дело в том что данная функция вызывается для каждой вакансии и результат полученных данных нужно записать в таблицу. (после выхода из функции все объекты созданные в ней удаляются), по этому таблица создается вне функции, глобально, и что бы получить доступ к глобальной таблице нужна эта строка\nВ этот список будут помещены слова найденные на странице (список слов указан в переменной keywords)\nСобственно сам поиск этих ключей указанных в keywords, берется каждый ключ по очереди\nИ производиться поиск ключа (слова) по объекту response.text который вернул запрос к сайту\nЕсли ключ найден на странице он добавляется в пустой список fkeys (который создали ранее)\nИщем нужные данные в локальном html который спарсили, в данном случае, это теги в нижней части страницы\n\nНа прошлом шаге мы получаем кусок html кода с нужными тегами, данная строка извлекает текст тега и помещает в список\n\nИзвлекаем header\nПолучаем название вакансии\nПолучаем ставку (указанную зарплату)` Примечание: есть вакансии на которых указанной зарплаты нет, а бывают случаи когда указан диапазон от…до, такие моменты обрабатываю ниже\n\nпроверяем, указана зарплата\nрегулярным выражением ищем только число (убираем символы)\nпреобразовываем в число\nесли зарплата не указано, помечаем переменную как Nane\n\nполученные данные записываем в таблицу\n\n\n\nПереход по страницам и поиск ссылок\nЭтот цикл сканирует главные страницы (на которых находятся вакансии), в зависимости от итерации переходит по страницам 2,3,4… на самом сайте\n\n\nКод\nfor p in range(9):              # 1\n    if p &gt; 0:\n        url = f'{start_url}&page={p}' # 2\n        print(f\"--- Page {p} --- --- ---\")\n\n    # Поиск всех ссылок внутри тегов h2\n    for i in range(9):          # 3\n        time.sleep(3)           # 4\n        print(f\"--- --- --- Iteration {i}\")\n        response = requests.get(url, headers=headers) # 5\n        soup = BeautifulSoup(response.text, 'html.parser') # 6\n        if soup.find_all('h2'):                            # 7\n            for h2 in soup.find_all('h2'):                 # 7.1\n                for a in h2.find_all('a', href=True):      # 7.2\n                    absolute_url = requests.compat.urljoin(url, a['href']) # 7.3\n                    check_correctly(absolute_url) # 8\n            break                                 # 9\n\n\n\nУказываем кол-во страниц (главных) по на которых будет смотреть вакансии\nЕсли это не первая итерация цикла, то к ссылке добавляем page и цифру страницы (цифру итерации цикла)\nБывает hh.ru возвращает не полную страницу, в этом цикле проверяем корректность полученной страницы, если она не полная повторяем запрос вплоть до получения полной страницы или в плоть до числа в функции range()\nПеред каждым новым запросом немного ждем, что бы не DDOSить сайт, все таки цель получить данные, имитируем простой переход\nСам запрос на получение данных с сайта, url - ссылка данные которой запрашиваем, headers - это имитация пользователя которая создавалась ранее\nПарсим полученный объект (теперь в этой переменной лежит “грубо говоря” html страница), которую можно парсить. Преимущество в том, что при тестах не делается запрос на сайт\nПроверяем полученную страницу, если она не полная то делаем запрос еще раз (переходим на новую итерацию)\nЕсли страница полная, извлекаем h2 (заголовок вакансии)\nВ этом заголовке ищем ссылку на вакансию\nИз этой ссылки делаем абсолютный путь (полную ссылку на вакансию)\nПередаем ссылку на вакансию в переменную проверки\nНа данном этапе то как мы попали в if soup.find all(‘h2’), значит мы получили полную ссылку на страницу, делать новый запрос по той же ссылке не нужно\n\n\n\nСохранить\nСохраняем результат в xlsx файл\n\n\nКод\nwb = xlsxwriter.Workbook('Output.xlsx')\n\n# 1 sheet DF\ndf.write_excel(\n    workbook= wb,\n    worksheet='DF',\n    position=\"A1\",\n    table_style=\"Table Style Medium 3\",\n    dtype_formats={pl.Date: \"mm/dd/yyyy\"},\n    column_totals={\"num\": \"average\"},\n    float_precision=1,\n    autofit=True,\n)\n\nwb.close()\n\n\n\n\nРезультат\n\n\n\n\n\n Наверх"
  },
  {
    "objectID": "content/portfolio/posts/p4.html",
    "href": "content/portfolio/posts/p4.html",
    "title": "Красивый экспорт в Excel (xlsx)",
    "section": "",
    "text": "Примечание\n\n\n\nВ данной статье в вкратце описываются функции пакета openxlsx. Ниже приведен пример взаимодействия функций и итоговый результат экспорта таблицы из R → xlsx\n\n\n\nБиблиотеки и стили\n\nlibrary(openxlsx)\n\n## --- Цвета\ngray   &lt;- createStyle(fgFill = '#d9d9d9')\ngreen  &lt;- createStyle(fgFill = '#c6e0b4')\nred    &lt;- createStyle(fgFill = '#f9a1a1')\nblue   &lt;- createStyle(fgFill = '#bdd7ee')\nyellow &lt;- createStyle(fgFill = '#ffe699')\nros    &lt;- createStyle(fgFill = '#fce4d6')\nborder &lt;- createStyle(fgFill = '#333333')\n\n## --- Стили\nst_bord &lt;- createStyle(numFmt = \"#,##0\",\n                       border = 'TopBottomLeftRight',borderColour = '#cccccc')\nst_head &lt;- createStyle(textDecoration = \"bold\", halign = \"center\",\n                       border = 'TopBottomLeftRight',borderColour = border)\nst_bot  &lt;- createStyle(textDecoration = 'bold',border = \"top\",\n                       borderColour = border,borderStyle = \"medium\")\nst_name &lt;- createStyle(halign = \"center\", textDecoration = 'bold',\n                       fontSize = 16, border = 'TopBottomLeftRight',\n                       borderColour = border, borderStyle = 'medium')\nst_bold &lt;- createStyle(textDecoration = 'bold',border = \"left\",\n                       borderColour = border,borderStyle = \"medium\")\n\n\n\nКнига и опции\nСоздаем книгу (объект в ram) и страницу в этой книге с названием Продажи, к которой применяем несколько опций: - orientation :: portrait - указывает ореинтацию бумаги (опция для печати на бумагу) - pageSetup :: параметры для отступа от краев страницы (помогает вместить больше информации на слит при печати на бумагу)\n\n## создаем книгу\nwb &lt;- createWorkbook()\n\n## добавляем лист в книгу xlsx\naddWorksheet(wb, sheetName = \"Продажи\", orientation = 'portrait', gridLines = FALSE)\n\n## устанавливаем отступы\npageSetup(wb, \"Продажи\", left = 0.25, top = 0.25, right = 0.25,bottom = 0.25)\n\n\n\nЗапись и кастомизация\n\nmergeCells - соединяет ячейки (диапазон соединения определяется автоматически) cols = 1:length(fin_sales)\naddStyle - применяет стиль “st_name” к указанной области\nsetColWidths - устанавливает ширену колонки\n\n\n## записываем данные на xlsx лист\nwriteData(wb, 'Продажи', \"Продажи\")\n\n## соединяем ячейки\nmergeCells(wb, sheet = \"Продажи\", cols = 1:length(fin_sales), rows = 1)\n\n## применяем стиль st_name к 1 сроке с 1 столбца по значение длинны таблицы fin_sales\naddStyle(wb, 'Продажи', st_name, 1, 1:length(fin_sales), stack = TRUE)\n\nwriteData(wb, 'Продажи', fin_sales, startRow = 3)\naddStyle(wb, 'Продажи', st_head, 3, 1:length(fin_sales),\n         gridExpand = TRUE, stack = TRUE)\n\n## установить ширену столбцов\nsetColWidths(wb, \"Продажи\", cols = 1, widths = 25)\n\naddStyle(wb, 'Продажи', st_bord, 4:(nrow(fin_sales)+3),\n         1:length(fin_sales), stack = TRUE, gridExpand = TRUE)\n\n## применяет стиль st_bot к ячейкам столбца где есть данные\naddStyle(wb, 'Продажи', st_bot, (which(!is.na(temp_sales$PROC))+3),\n         1:length(temp_sales), stack = TRUE, gridExpand = TRUE)\n\naddStyle(wb, 'Продажи', st_bot, nrow(fin_sales)+3, 1:length(fin_sales), stack = TRUE)\naddStyle(wb, 'Продажи', createStyle(halign = \"center\"),\n         3:(nrow(fin_sales)+3), length(fin_sales), stack = TRUE, gridExpand = TRUE)\nsetColWidths(wb, \"Продажи\", cols = length(fin_sales), widths = 18)\naddStyle(wb, 'Продажи', gray, 3, 1, stack = TRUE)\naddStyle(wb, 'Продажи', ros, 3, c(2,3), stack = TRUE, gridExpand = TRUE)\naddStyle(wb, 'Продажи', green, 3, 4, stack = TRUE)\naddStyle(wb, 'Продажи', blue, 3, 5, stack = TRUE)\naddStyle(wb, 'Продажи', yellow, 3, 6, stack = TRUE)\n\n\n\nРезультат\n\n\n\nЗаключение\nДанный метод сохранения в xlsx с одной стороны “многословен”, но с другой стороны очень гибок в настройке, он позволяет записать/применять стиль вплоть до ячейки.\nЕсли на постоянной основе делается однотипный отчет, в котором просто обновляются данные, то этот подход имет смысл, а в долгосрочной перспективе, окупиться в следующих итерациях формирования отчета\n\n\n\n\n Наверх"
  },
  {
    "objectID": "content/portfolio/posts/p1.html",
    "href": "content/portfolio/posts/p1.html",
    "title": "Продажи предприятий",
    "section": "",
    "text": "Binol магазины с площадью до 15м²\nПредставленный график отображает помесячную динамику продаж. Данные показывают, что объемы продаж в таких торговых точках подвержены значительным колебаниям в течение года\n\n\n\n\n\n\nПримечание\n\n\n\nПо магазину ул. Кирова 50/3 данные отсутсвуют, в связи с закрытием\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinol магазины с площадью от 15м²\n\n\n\n\n\n\n\n\n\n\n\n\nИтого по месяцам\nОбщая сумма выручки от продажи цветов Binol и Olive\n\n\n\n\n\n\nПримечание\n\n\n\nОт общей суммы продаж по магазинам отнималась сумма выручки Olive, Т.е. в показателях Binol так же находится сторонняя продукция (торговый склад)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Наверх"
  },
  {
    "objectID": "content/blog/posts/b1.html",
    "href": "content/blog/posts/b1.html",
    "title": "Emacs против других IDE",
    "section": "",
    "text": "Emacs - один из самых старых текстовых редакторов, выпущен 1985 году, помимо своего внушительного возраста этот редактор удивил меня своей разносторонностью и настраиваемостью.\nКак может выглядеть такой древний софт?\n\nНе очень привлекательно… Но внеся изменения в файл конфигурации можно получить такой вид\n\nВпрочем, это только визуалальная сторона, Emacs так же может удивить по функциональности\n\n\n\nEmacs - это не просто текстовый редактор, у него есть терминал, браузер, файловый менеджер, менеджер задач, возможность просматривать изображения, pdf файлы… А еще есть org mode! И все это “из коробки”! Казалось бы, это не редактор, это контейнер с утилитами, он наверное долго грузиться и медленно работает? Запускается emacs за &gt;0.1s! при этом потребляет ~30мб ОЗУ! Да… Умели раньше делать софт!\nКонечно в этом есть подвох, это показатели “ванильного” Emacs, то есть, Emacs из коробки без настроек (вспомним первое фото поста), мой рабочий(настроенный) emacs запускается за ~0.45сек и потребляет ~90мб, сравните с популярными IDE (а я дальше сравню!)\nВанильный Emacs представляет собой ядро на которое налаживаются пакеты и настройки для того что бы подстроить редактор под себя. Начиная от внешнего вида, заканчивая горячими клавишами.  Можно задаться вопросом, разве популярные IDE не дают возможность настроить hotkeys и темы? Да, дают, но в меру, очень быстро можно упереться в потолок. Emacs это GUI для языка Emacs Lisp, используя этот язык можно программировать сам Emacs, его поведение, реализовывать дополнительный функционал, это не просто визуальная настройка, это реализация недостающего функционала. Кто увлекается программированием, и не сторонник “IDE из коробки работает - мне этого хватает” - того Emacs может приятно удивить\n\n\n\nУ Emacs есть много режимов, вкратце затрагивал в разделе функциональность, но о 2х режимах расскажу немного больше.\nOrg mode - этот режим дает возможность писать наподобие markdown (по возможностям markdown это верхушка айсберга). В org mode можно использовать маркировки для выделения текста, ставить оглавления, вставлять блоки кода, таблицы, сноски, а так же можно экспортировать блоки кода в файл(ы) и экспортировать в другие форматы… Это очень мощный мод в котором я пишу конфигурации к приложениям. Это уникальный подход, который дает удобно описывать (комментировать) вне блоков кода, а сам код экспортировать в нужный файл без комментариев.\nAgenda - менеджер задач, который берет задачи из org файлов. Задачам можно назначить приоритет, статус, теги, можно настроить иерархию отображения, назначить scheduled и deadlaine, effort и множество других опций"
  },
  {
    "objectID": "content/blog/posts/b1.html#вступление",
    "href": "content/blog/posts/b1.html#вступление",
    "title": "Emacs против других IDE",
    "section": "",
    "text": "Emacs - один из самых старых текстовых редакторов, выпущен 1985 году, помимо своего внушительного возраста этот редактор удивил меня своей разносторонностью и настраиваемостью.\nКак может выглядеть такой древний софт?\n\nНе очень привлекательно… Но внеся изменения в файл конфигурации можно получить такой вид\n\nВпрочем, это только визуалальная сторона, Emacs так же может удивить по функциональности"
  },
  {
    "objectID": "content/blog/posts/b1.html#функциональность",
    "href": "content/blog/posts/b1.html#функциональность",
    "title": "Emacs против других IDE",
    "section": "",
    "text": "Emacs - это не просто текстовый редактор, у него есть терминал, браузер, файловый менеджер, менеджер задач, возможность просматривать изображения, pdf файлы… А еще есть org mode! И все это “из коробки”! Казалось бы, это не редактор, это контейнер с утилитами, он наверное долго грузиться и медленно работает? Запускается emacs за &gt;0.1s! при этом потребляет ~30мб ОЗУ! Да… Умели раньше делать софт!\nКонечно в этом есть подвох, это показатели “ванильного” Emacs, то есть, Emacs из коробки без настроек (вспомним первое фото поста), мой рабочий(настроенный) emacs запускается за ~0.45сек и потребляет ~90мб, сравните с популярными IDE (а я дальше сравню!)\nВанильный Emacs представляет собой ядро на которое налаживаются пакеты и настройки для того что бы подстроить редактор под себя. Начиная от внешнего вида, заканчивая горячими клавишами.  Можно задаться вопросом, разве популярные IDE не дают возможность настроить hotkeys и темы? Да, дают, но в меру, очень быстро можно упереться в потолок. Emacs это GUI для языка Emacs Lisp, используя этот язык можно программировать сам Emacs, его поведение, реализовывать дополнительный функционал, это не просто визуальная настройка, это реализация недостающего функционала. Кто увлекается программированием, и не сторонник “IDE из коробки работает - мне этого хватает” - того Emacs может приятно удивить"
  },
  {
    "objectID": "content/blog/posts/b1.html#org-mode-и-agenda",
    "href": "content/blog/posts/b1.html#org-mode-и-agenda",
    "title": "Emacs против других IDE",
    "section": "",
    "text": "У Emacs есть много режимов, вкратце затрагивал в разделе функциональность, но о 2х режимах расскажу немного больше.\nOrg mode - этот режим дает возможность писать наподобие markdown (по возможностям markdown это верхушка айсберга). В org mode можно использовать маркировки для выделения текста, ставить оглавления, вставлять блоки кода, таблицы, сноски, а так же можно экспортировать блоки кода в файл(ы) и экспортировать в другие форматы… Это очень мощный мод в котором я пишу конфигурации к приложениям. Это уникальный подход, который дает удобно описывать (комментировать) вне блоков кода, а сам код экспортировать в нужный файл без комментариев.\nAgenda - менеджер задач, который берет задачи из org файлов. Задачам можно назначить приоритет, статус, теги, можно настроить иерархию отображения, назначить scheduled и deadlaine, effort и множество других опций"
  },
  {
    "objectID": "content/blog/index.html",
    "href": "content/blog/index.html",
    "title": "Добро пожаловать в блог / Eno",
    "section": "",
    "text": "Здесь вы можете познакомиться с моими попытками обучения, а также прочитать о других полезных моментах.\n\n\n\n\n\n\n   \n     \n     \n       Сортировать по\n       предварительно выбранный\n         \n          Дата - Самый старый\n        \n         \n          Дата - Новейшие\n        \n         \n          Автор\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nПерсональная база знаний\n\n\n\n\n\nOrg Roam\n\n\n\n\n\n02 августа 2024\n\n\n2 минут\n\n\n\n\n\n\n\n\n\n\n\n\nEmacs против других IDE\n\n\n\n\n\nзнакомы с Emacs?\n\n\n\n\n\n11 июля 2024\n\n\n4 минут\n\n\n\n\n\n\nНет подходящих элементов\n\n\n\n\n\n\n\n\n Наверх"
  },
  {
    "objectID": "content/portfolio/posts/p3.html",
    "href": "content/portfolio/posts/p3.html",
    "title": "Продажа твердого сыра",
    "section": "",
    "text": "1 Продажи в разрезе видов продукта\nПример круговой диаграммы используя библиотеку plotrix\n\n\n\n\n\n\n\n\n\n\n\n\n\n Наверх"
  },
  {
    "objectID": "content/portfolio/posts/p2.html",
    "href": "content/portfolio/posts/p2.html",
    "title": "Разрез выручки",
    "section": "",
    "text": "В экосистеме языка R есть пакет WebR который позволяет создать круговую диаграмму такого вида\n\n\n\n\n\n\n\n\n\n\n\n\nPlotly - универсальный фреймворк, доступен как в Python так и в R. Позволяет буквально в пару строк создавать интерактивную круговую диаграмму"
  },
  {
    "objectID": "content/portfolio/posts/p2.html#r",
    "href": "content/portfolio/posts/p2.html#r",
    "title": "Разрез выручки",
    "section": "",
    "text": "В экосистеме языка R есть пакет WebR который позволяет создать круговую диаграмму такого вида"
  },
  {
    "objectID": "content/portfolio/posts/p2.html#python",
    "href": "content/portfolio/posts/p2.html#python",
    "title": "Разрез выручки",
    "section": "",
    "text": "Plotly - универсальный фреймворк, доступен как в Python так и в R. Позволяет буквально в пару строк создавать интерактивную круговую диаграмму"
  },
  {
    "objectID": "content/portfolio/index.html",
    "href": "content/portfolio/index.html",
    "title": "Портфолио",
    "section": "",
    "text": "Данная страница представляет собой визуальное и текстовое приставление моих навыков\nЗдесь я собрал наиболее яркие примеры моих работ\n\n\n\n   \n     \n     \n       Сортировать по\n       предварительно выбранный\n         \n          Дата - Самый старый\n        \n         \n          Дата - Новейшие\n        \n         \n          Автор\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nРазрез выручки\n\n\n1 минут\n\n\nwebr, plotly\n\n\n\n\n\n\n03 июля 2024\n\n\n\n\n\n\n\n\n\n\n\n\nПродажи предприятий\n\n\n5 минут\n\n\nggplot2, scales\n\n\n\n\n\n\n01 июля 2024\n\n\n\n\n\n\n\n\n\n\n\n\nПродажа твердого сыра\n\n\n1 минут\n\n\nplotrix\n\n\n\n\n\n\n06 июля 2024\n\n\n\n\n\n\n\n\n\n\n\n\nКрасивый экспорт в Excel (xlsx)\n\n\n4 минут\n\n\nopenxlsx\n\n\n\n\n\n\n10 июля 2024\n\n\n\n\n\n\n\n\n\n\n\n\nВеб-скрейпинг\n\n\n9 минут\n\n\nrequests bs4\n\n\n\n\n\n\n20 июля 2024\n\n\n\n\n\n\n\n\nНет подходящих элементов\n\n\n\n\n\n\n Наверх"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Шевченко Владимир",
    "section": "",
    "text": "ДАТА РОЖДЕНИЯ\n29.08.1997 г. (26 лет)\n\n\nПОЛ\nМужской\n\n\nСЕМЕЙНОЕ ПОЛОЖЕНИЕ\nХолост\n\n\nОБРАЗОВАНИЕ\nВысшее\n\n\nМЕСТОНАХОЖДЕНИЕ\nМелитополь\n\n\nПоиск работы\nРассматриваю предложения"
  },
  {
    "objectID": "about.html#section",
    "href": "about.html#section",
    "title": "Шевченко Владимир",
    "section": "2016 – 2020",
    "text": "2016 – 2020\n\n\n\n\n\n\n\nУЧЕБНОЕ ЗАВЕДЕНИЕ\nТаврический Государственный Агротехнологический Университет\n\n\nСПЕЦИАЛЬНОСТЬ\nIT\n\n\nФАКУЛЬТЕТ\nКомпьютерные науки\n\n\nФОРМА ОБУЧЕНИЯ\nОчная"
  },
  {
    "objectID": "about.html#программирование",
    "href": "about.html#программирование",
    "title": "Шевченко Владимир",
    "section": "Программирование",
    "text": "Программирование\n\n\n\nGo\ncolly, go-telegram\n\n\nDocker\nиспользование шаблонов"
  },
  {
    "objectID": "about.html#os-и-ide",
    "href": "about.html#os-и-ide",
    "title": "Шевченко Владимир",
    "section": "OS и IDE",
    "text": "OS и IDE\nПредпочитаемые инструменты\n\n\n\nLinux\nEmacs\nDbeaver"
  },
  {
    "objectID": "about.html#июнь-2023---декабрь-2023",
    "href": "about.html#июнь-2023---декабрь-2023",
    "title": "Шевченко Владимир",
    "section": "июнь 2023 - декабрь 2023",
    "text": "июнь 2023 - декабрь 2023\n\n\n\nДОЛЖНОСТЬ\nЭкономист\n\n\n\n\nОРГАНИЗАЦИЯ\nOOO «Мелитопольский молокозавод»\n\n\nОПЫТ РАБОТЫ\n~7 мес\n\n\n\nДОЛЖНОСТНЫЕ ОБЯЗАННОСТИ: ➢ составление / обновление отчета по 3м предприятиям: (ММЗ, Сыры Таврии, Дельфин) сбор, обработка, визуализация данных\n➢ анализ продаж по магазинам, факт + прогноз\n➢ просчет себестоимости продуктов"
  },
  {
    "objectID": "about.html#ноябрь-2020---октябрь-2022",
    "href": "about.html#ноябрь-2020---октябрь-2022",
    "title": "Шевченко Владимир",
    "section": "ноябрь 2020 - октябрь 2022",
    "text": "ноябрь 2020 - октябрь 2022\n\n\n\nДОЛЖНОСТЬ\nГлавный специалист управления риск-менеджмента\n\n\n\n\nОРГАНИЗАЦИЯ\nOOO «Forward Bank»\n\n\nОПЫТ РАБОТЫ\n~ 2 года\n\n\n\nДОЛЖНОСТНЫЕ ОБЯЗАННОСТИ:\n➢ формирования отчетов нормы пропуска и рисков\n➢ ежемесячные отчеты (графики + данные в разрезе)\n➢ проверка клиентов по базе (по черному списку, личной информации, BKI, PTI…)\n➢ написание и оптимизация скриптов, так же (функций, процедур)\n➢ администрирование таблиц в базе (создание, удаление, заполнение, изменение типов данных…)\n➢ привидения исходных данных в «чистый вид», обработка данных (разрезы, агрегация, фильтры…)"
  },
  {
    "objectID": "about.html#section-1",
    "href": "about.html#section-1",
    "title": "Шевченко Владимир",
    "section": "2016 - 2018",
    "text": "2016 - 2018\n\n\n\nДОЛЖНОСТЬ\nТех Поддержка\n\n\n\n\nОРГАНИЗАЦИЯ\nЧП «Band»\n\n\nОПЫТ РАБОТЫ\n~ 2 года\n\n\n\nДОЛЖНОСТНЫЕ ОБЯЗАННОСТИ:\n➢ удаленная тех поддержка сотрудников\n➢ установка  настройка программ для Windows  Linux\n➢ аренда и поддержка VPS  VDS\n➢ автоматизация рабочих процессов"
  },
  {
    "objectID": "content/blog/posts/b2.html",
    "href": "content/blog/posts/b2.html",
    "title": "Персональная база знаний",
    "section": "",
    "text": "В наши дни существуют множество инструментов для ведения заметок, такие как Obsidian, Tana, Logseq…  Инструменты различаются подходами ведения заметок, функционалом и не менее важным это “философией”. Одни инструменты открыты, другие хранят пользовательские заметки на серверах. Для некоторых последний критерий важен, в том числе и для меня\n\n\n\n\n\n\nСловарь\n\n\n\n\npkm - управление личными знаниями (personal knowledge management)"
  },
  {
    "objectID": "content/blog/posts/b2.html#obsidian",
    "href": "content/blog/posts/b2.html#obsidian",
    "title": "Персональная база знаний",
    "section": "Obsidian",
    "text": "Obsidian\nObsidian - один из популярных инструментов для ведения заметок, хорошо подходит в качестве персональной базы знаний. Плюсы: - Работает быстро - Имеет неплохую кастомизацию - Имеет большое кол-во плагинов\nМинусы - Закрытый код"
  },
  {
    "objectID": "content/blog/posts/b2.html#logseq",
    "href": "content/blog/posts/b2.html#logseq",
    "title": "Персональная база знаний",
    "section": "Logseq",
    "text": "Logseq\nLogseq - инструмент с открытым исходным кодом, специализирующийся как инструмент для персональной базы знаний. Плюсы:  - Имеет множество интересных функций такие как: | + “обратные ссылки” 4 | + систему запроса (DataLog) 5 | + менеджер задач - Не плохая кастомизация\n4 отображение страниц которые ссылаются на текущую страницу5 позволяет выполнять запросы к данным заметок для извлечения и анализа информацииМинусы: - Небольшое кол-во плагинов"
  },
  {
    "objectID": "content/blog/posts/b2.html#tana",
    "href": "content/blog/posts/b2.html#tana",
    "title": "Персональная база знаний",
    "section": "Tana",
    "text": "Tana\nTana - это система управления знаниями, которая считается одним из самых продвинутых инструментов для pkm Я не использовал данный инструмент, в связи с тем, что он не соответствует моим требованиям. Инструмент закрыт, пользовательские заметки хранятся на сервере данного приложения.\nТак что указать плюсы и минусы не смогу, только слышал что данный инструмент весьма хороший."
  }
]